diff --git a/part_b/tasksys.cpp b/part_b/tasksys.cpp
index c1e8a5c..29695c9 100644
--- a/part_b/tasksys.cpp
+++ b/part_b/tasksys.cpp
@@ -182,22 +182,32 @@ TaskSystemParallelThreadPoolSleeping::TaskSystemParallelThreadPoolSleeping(
           if (stop_ && ready_queue_.empty())
             break;
 
-          bw = ready_queue_.front();
-          int got = bw->next_idx_.fetch_add(1);
-          if (got >= bw->total_work) {
-            cv_ready_.wait(lk, [this, bw] {
-              return stop_ || ready_queue_.empty() ||
-                     ready_queue_.front() != bw;
-            });
+          bool found = false;
+          size_t qn = ready_queue_.size();
+          // 轮转查找可分配任务
+          for (size_t r = 0; r < qn; r++) {
+            BatchWork *cand = ready_queue_.front();
+            ready_queue_.pop();
+            int got = cand->next_idx_.fetch_add(1);
+            if (got < cand->total_work) {
+              ready_queue_.push(cand); // 轮转
+              bw = cand;
+              idx = got;
+              total = cand->total_work;
+              fn = cand->func;
+              found = true;
+              break;
+            } else {
+              // 任务索引已分发完，放回原队列位置
+              ready_queue_.push(cand);
+            }
+          }
+          if (!found) {
+            // 没有可执行 index，继续等待新提升
             continue;
           }
-
-          idx = got;
-          total = bw->total_work;
-          fn = bw->func;
         }
 
-        // 锁外执行
         fn->runTask(idx, total);
 
         {
@@ -206,25 +216,20 @@ TaskSystemParallelThreadPoolSleeping::TaskSystemParallelThreadPoolSleeping(
           if (left_after == 0) {
             done_.insert(bw->batch_id);
             pending_batches_--;
-            // 防御性编程
-            if (!ready_queue_.empty() && ready_queue_.front() == bw) {
+            // 从 ready_queue_ 移除该批
+            std::queue<BatchWork *> tmp;
+            while (!ready_queue_.empty()) {
+              BatchWork *cur = ready_queue_.front();
               ready_queue_.pop();
-            } else {
-              std::queue<BatchWork *> tmp;
-              while (!ready_queue_.empty()) {
-                BatchWork *cur = ready_queue_.front();
-                ready_queue_.pop();
-                if (cur != bw)
-                  tmp.push(cur);
-              }
-              ready_queue_.swap(tmp);
+              if (cur != bw)
+                tmp.push(cur);
             }
-
-            // 提升可执行批次并通知
+            ready_queue_.swap(tmp);
             updateQueue();
             if (pending_batches_ == 0)
               cv_done_.notify_all();
-            cv_ready_.notify_all();
+            if (!ready_queue_.empty())
+              cv_ready_.notify_all();
           }
         }
       }
@@ -252,7 +257,7 @@ void TaskSystemParallelThreadPoolSleeping::run(IRunnable *runnable,
 TaskID TaskSystemParallelThreadPoolSleeping::runAsyncWithDeps(
     IRunnable *runnable, int num_total_tasks, const std::vector<TaskID> &deps) {
   std::lock_guard<std::mutex> lk(mtx_);
-
+  
   TaskID id = next_batch_idx_++;
   std::unique_ptr<BatchWork> up(
       new BatchWork(num_total_tasks, id, runnable, deps));
